{"pages":[{"title":"关于我","text":"个人博客 简书 联系方式 邮箱：jssaxy@163.com","link":"/about/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/09/06/hello-world/"},{"title":"Android跳转到第三方app，运行时长监听","text":"1. 问题描述需要实现从我们app跳转到第三方app，并统计第三方app在前台所待时长的功能。 2. 问题分析大概过程如下：1）首先得有权限，我们这个需要实现允许查看应用使用情况、悬浮窗两个权限。2）跳转到第三方app；3）启动一个服务监听；4）弹出一个悬浮窗5）监听第三方app是否在前台运行。实现思路是启动一个定时器，每隔1s去查看前台应用信息。6）预期时间完成，销毁悬浮窗，解绑Service。 3. 实现过程3.1 悬浮窗 悬浮窗权限当我们自己app在后台运行时，无法弹出一个Toast或者Dialog，所以得做一个类似于360安全卫士一样的悬浮窗。所以得要申请悬浮窗权限。6.0之前只需要在AndroidManifest文件中申请：12&lt;uses-permission android:name=\"android.permission.SYSTEM_ALERT_WINDOW\"/&gt;&lt;uses-permission android:name=\"android.permission.SYSTEM_OVERLAY_WINDOW\"/&gt; 6.0之后，代码中动态申请，需要跳转到系统设置中去获取： 123456if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M){ if (!Settings.canDrawOverlays(MainActivity.this)){ Intent intent = new Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION, Uri.parse(\"package:\" + getPackageName())); startActivityForResult(intent, REQUESTCODE_OVER); }} 显示一个悬浮窗显示一个悬浮窗，首先写一个布局文件，然后添加到WindowManager中。123456789101112131415161718192021222324// LayoutInflater.from中Context用getApplicationContext()View view = LayoutInflater.from(getApplicationContext()).inflate(R.layout.layout_window,null);WindowManager mWindowManager = (WindowManager) getApplication().getSystemService(Context.WINDOW_SERVICE);WindowManager.LayoutParams params = new WindowManager.LayoutParams();//设置type.系统提示型窗口，一般都在应用程序窗口之上.if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O){ params.type = WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY;}else{ params.type = WindowManager.LayoutParams.TYPE_SYSTEM_ALERT;}//设置效果为背景透明.params.format = PixelFormat.RGBA_8888;//设置flags.不可聚焦及不可使用按钮对悬浮窗进行操控.params.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;//设置窗口初始停靠位置.params.gravity = Gravity.LEFT | Gravity.TOP;params.x = 0;params.y = 0;params.width = WindowManager.LayoutParams.MATCH_PARENT;params.height = WindowManager.LayoutParams.WRAP_CONTENT;mWindowManager.addView(view,params); 注意： 在Android 8.0后 params.type变化。具体参考： Android 8.0 悬浮窗变动与用法 3.2 监听app在前台运行Android检测app运行在前台，5.0以前是通过获取手机当前活跃进程列表，5.0后这种办法用不了了，5.0以后通过UsageStatsManager（统计服务类）来获取。 1）5.0之前通过ActivityManager获取运行app进程来判断app是否处于前台。 12345678910111213public boolean isRunningForeground(Context context,String packageName){ ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE); List&lt;ActivityManager.RunningAppProcessInfo&gt; processes = activityManager.getRunningAppProcesses(); for (ActivityManager.RunningAppProcessInfo processInfo: processes) { if (processInfo.processName.equals(context.getPackageName())) { if (processInfo.importance == ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND) { return true; } } } return false;} 2）5.0之后Android5.0之后通过UsageStatsManager（统计服务类） 申请“允许查看应用使用情况”。 5.0以后查看应用使用情况 12&lt;uses-permission android:name=\"android.permission.PACKAGE_USAGE_STATS\" tools:ignore=\"ProtectedPermissions\"/&gt; 在代码中，我们也做一层判断，是否已经获取该权限，如果没有，则跳转到设置权限界面： 12Intent intent = new Intent(Settings.ACTION_USAGE_ACCESS_SETTINGS);startActivityForResult(intent,REQUESTCODE_USAGE); 获取最近运行app1234567891011121314151617181920212223242526272829303132333435363738public String getRunningPackageNameOver21(Context context){ String topPackageName = \"\"; if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP){ return topPackageName; } // 1.获取统计服务类 UsageStatsManager usageStatsManager = (UsageStatsManager) context.getSystemService(Context.USAGE_STATS_SERVICE); long currTime = System.currentTimeMillis(); //2.获取从今天0点到现在的使用情况 List&lt;UsageStats&gt; usageStatsList = usageStatsManager.queryUsageStats(UsageStatsManager.INTERVAL_DAILY, getStartTime(),currTime); //3.根据最后使用时间降序排列 Collections.sort(usageStatsList,new UsageComparator()); //获取前台应用，排除其他应用因通知栏而产生的统计信息 Field mLastEventField = null; try { mLastEventField = UsageStats.class.getField(\"mLastEvent\"); } catch (NoSuchFieldException e) { e.printStackTrace(); } for (UsageStats usageStats:usageStatsList){ if (mLastEventField != null){ int lastEvent = 0; try { lastEvent = mLastEventField.getInt(usageStats); } catch (IllegalAccessException e) { e.printStackTrace(); } if (lastEvent == 1){ topPackageName = usageStats.getPackageName();// Log.i(TAG,\"包名:\" + usageStats.getPackageName() + \",:\" + dateFormat.format(new Date(date))); return topPackageName; } } } return topPackageName;} 4. 最后效果 源码：https://github.com/AnXy1218/AppRunTime","link":"/2019/10/07/Android/Android-jump-other/"},{"title":"java实现一张透明背景的图片，添加图片水印","text":"java实现一张透明背景的图片，添加图片水印 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public static void createWaterMarkByIcon(File srcImageFile, File logoImageFile, File outputImageFile, double degree) { OutputStream os = null; try { Image srcImg = ImageIO.read(srcImageFile); BufferedImage buffImg = new BufferedImage(srcImg.getWidth(null), srcImg.getHeight(null), BufferedImage.TYPE_INT_RGB); Graphics2D graphics = buffImg.createGraphics(); buffImg = graphics.getDeviceConfiguration().createCompatibleImage(srcImg.getWidth(null), srcImg.getWidth(null), Transparency.TRANSLUCENT); graphics = buffImg.createGraphics();// graphics.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR); int imgWidth = srcImg.getWidth(null); int imgHeight = srcImg.getHeight(null); graphics.drawImage(srcImg.getScaledInstance(srcImg.getWidth(null), srcImg.getHeight(null), Image.SCALE_SMOOTH), 0, 0, null); ImageIcon logoImgIcon = new ImageIcon(ImageIO.read(logoImageFile)); Image logoImg = logoImgIcon.getImage(); //旋转 if (degree&gt;0) { graphics.rotate(Math.toRadians(degree), (double) buffImg.getWidth() / 2, (double) buffImg.getWidth() / 2); } float alpha = 0.7f; // 透明度 graphics.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, alpha)); //水印 的位置 int logoWidth = imgWidth/4; int logoHeight = logoWidth*17/20; graphics.drawImage(logoImg, buffImg.getWidth()-logoWidth, buffImg.getHeight()-logoHeight,logoWidth,logoHeight, null);// graphics.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER)); graphics.dispose(); os = new FileOutputStream(outputImageFile); // 生成图片 ImageIO.write(buffImg, \"PNG\", os); } catch (Exception e) { e.printStackTrace(); } finally { try { if (null != os) os.close(); } catch (Exception e) { e.printStackTrace(); } } } 水印位置根据自己实际情况调整。参考文档：https://blog.csdn.net/gingerredjade/article/details/53193014","link":"/2019/12/07/java/imgWaterSeal/"},{"title":"Android跳转到第三方app，运行时长监听","text":"最近在做项目的时候，有这样一个需求，要实现取件码的输入，效果图如下： 看到这个图，立马想到，这个类似于支付宝、微信的密码输入框。 实现方法总结：一、直接写四个EditText，然后对其设置maxLength为1。12345678&lt;EditText android:id=\"@+id/et_inputPickupNum1\" android:layout_width=\"40dp\" android:layout_height=\"40dp\" android:inputType=\"number\" android:gravity=\"center\" android:maxLength=\"1\" android:background=\"#0000ff\"/&gt; 在代码中，对其设置监听事件，事件主要功能如下：1）当有输入后，立马使其失去焦点，同时让下一个EditText获取焦点。2）当删除的时候，使其使其失去焦点，同时让前一个获取焦点。 12345678910111213141516171819202122232425etPickupNum2.addTextChangedListener(new TextWatcher() { @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) { } @Override public void onTextChanged(CharSequence s, int start, int before, int count) { if (!TextUtils.isEmpty(s.toString().trim())){ etPickupNum2.clearFocus(); etPickupNum2.setFocusable(false); etPickupNum3.setFocusable(true); etPickupNum3.setFocusableInTouchMode(true); etPickupNum3.requestFocus(); }else{ etPickupNum2.clearFocus(); etPickupNum1.setFocusable(true); etPickupNum1.setFocusableInTouchMode(true); etPickupNum1.requestFocus(); } } @Override public void afterTextChanged(Editable s) { }}); 不过，这种实现方式代码量大，可扩展性差。这种实现方式，还存在一个问题，就是删除一个后，光标跳到前一个去了，继续输入还得点一下EditText。二、在同一个布局容器中添加四个TextView，用于显示输入后的文字。同时在这个布局容器上边添加一个背景透明的、隐藏了光标、字体也是透明的EditText。在代码中，对EditText设置输入监听事件。1）xml文件中： 123456789101112131415161718192021222324252627282930313233343536&lt;RelativeLayout android:layout_width=\"match_parent\" android:layout_height=\"40dp\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"horizontal\"&gt; &lt;TextView android:id=\"@+id/tv_inputPickupNum1\" android:layout_width=\"40dp\" android:layout_height=\"40dp\" android:textColor=\"#ffffff\" android:background=\"#0000ff\"/&gt; &lt;View android:layout_weight=\"1\" android:layout_width=\"0dp\" android:layout_height=\"match_parent\"/&gt; ....... &lt;/LinearLayout&gt; &lt;EditText android:id=\"@+id/et_inputPickupNum\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:maxLength=\"4\" android:background=\"@android:color/transparent\" android:textColor=\"@android:color/transparent\" &lt;!--cursorVisible设置为false，表示隐藏光标--&gt; android:cursorVisible=\"false\"/&gt;&lt;/RelativeLayout&gt; 2）代码中： 1234567891011121314151617181920212223etnum.addTextChangedListener(new TextWatcher() { @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) { } @Override public void onTextChanged(CharSequence s, int start, int before, int count) { //numList是一个存放四个TextView的集合 for (TextView tvNum:numList){ tvNum.setText(\"\"); } String str = s.toString().trim(); if (!TextUtils.isEmpty(str)){ for(int i = 0;i &lt; str.length();i++){ numList.get(i).setText(str.substring(i,i+1)); } } } @Override public void afterTextChanged(Editable s) { }}); 这种和第一种比较，就是不用考虑焦点的得失。三、自定义View。实现思路是：1） 定义内容背景颜色、间距、间距颜色、字体颜色等属性。2）在xml中设置这些属性值。3）写一个类继承EditText，获取上边属性值，并且实现输入事件监听。4）做全局配置：让该EditText获取焦点，再设置最大长度。设置字体颜色为透明，隐藏光标。 123456789101112131415private void initView() { setFocusable(true); setFocusableInTouchMode(true); this.setFilters(new InputFilter[]{new InputFilter.LengthFilter(maxLength)}); this.setTextColor(Color.TRANSPARENT); this.setGravity(Gravity.CENTER_VERTICAL); if(mPaint == null){ mPaint = new Paint(); } mPaint.setTextSize(textSize); mPaint.setColor(spacingColor); if (mBound == null){ mBound = new Rect(); }} 5）设置背景，实现四个显示框，以及中间间距。 1234567891011121314151617private void drawBackground(Canvas canvas) { //contentWidth为显示框宽度，spacingWidth为间距宽度，maxLength为最大长度 contentWidth = (getWidth() - spacingWidth*(maxLength-1))/maxLength; for (int i = 0;i &lt; maxLength;i++){ //contentColor为文本框背景颜色 mPaint.setColor(contentColor); Rect rect = new Rect(i*(spacingWidth + contentWidth),0,i*(spacingWidth + contentWidth) + contentWidth,getHeight()); canvas.drawRect(rect,mPaint); if (i != maxLength -1){ //spacingColor为间距的背景颜色 mPaint.setColor(spacingColor); Rect spacingRect = new Rect(i*(spacingWidth + contentWidth) + contentWidth,0,(i+1)*(spacingWidth + contentWidth),getHeight()); canvas.drawRect(spacingRect,mPaint); } } } 6）绘制文字。 1234567//content用于记录当前输入字符串mPaint.getTextBounds(content,0,content.length(),mBound);mPaint.setColor(textColor);for (int i = 0;i &lt; content.length();i++){ canvas.drawText(content.substring(i,i+1),i*(spacingWidth + contentWidth),getHeight()/2 + mBound.height()/2,mPaint);} 这种方式和第二种相比，缺点是需要计算文本显示区域，间距显示区域。优点是扩展性好一点。","link":"/2019/10/06/Android/appRun/"},{"title":"实现list的深拷贝","text":"本文引自：http://blog.sina.com.cn/s/blog_605f78830102uy6x.html1.先来看一段代码：1234567List&lt;A&gt; source = new ArrayList&lt;A&gt;(); List&lt;A&gt; copy = new ArrayList&lt;A&gt;();A a = new A(); a.setName(\"ABC“);source.add(a);copy.addAll(source); //通过addAll()方法拷贝copy.get(0).setName(\"CDE\"); 这时，获取source.get(0)的name值，也变成了“CDE”。为了解决这个问题，使得改变copy中的值，不影响source中的数据，则要进行深拷贝。即，对A类实现clone()方法： 12345678910111213141516171819public class A implements Cloneable{ private String name; public A(){ } public void setName(String name){ this.name = name; } public String getName(){ return name; } //实现这个方法 protected A clone() throws CloneNotSupportedException { return (A)super.clone(); }} 然后， 123for(int i = 0; i &lt; source.size();i++){ copy.add(source.get(i).clone()); } 就可以进行深拷贝了。 在此，再多描述一下关于Clone的内容。Java对对象和基本数据类型的处理是不一样的。在Java中用对象作为入口参数的传递则缺省为“引用传递”，也就是说仅仅传递了对象的一个“引用”，这个引用的概念与C语言中的指针引用是一样的。当函数体内部对这个变量进行改变时，实质上就是对这个对象进行直接操作。除此之外，在任何用“=”向对象变量赋值的时候都是“引用传递”。 一、当Class A的成员变量类型是基本数据类型（外加String类型）时，只要实现如上简单的clone（称影子clone）就可以。但是如果Class A的成员变量是数组或者更复杂类型时，就必须实现深度clone。 1234567891011121314151617181920public class A implements Cloneable{ private String[] name; public A(){ name = new String[2]; } public void setName(String[] name){ this.name = name; } public String[] getName(){ return name; } //实现这个方法 protected A clone() throws CloneNotSupportedException { return (A)super.clone(); }} 此处的A的成员变量String[],影子clone对name数组clone他们的地址，需进行深拷贝。 12345protected A clone() throws CloneNotSupportedException { A a = (A)super.clone(); a.name = (String[])name.clone(); return a;} 二、需要注意的是，Class A存在更为复杂的成员变量时，如Vector等存储对象地址的容器时，就必须clone彻底。 1234567891011121314151617181920212223242526272829303132333435public class A implements Cloneable{ private String[] name; private Vector&lt;B&gt; claB; public A(){ name = new String[2]; claB = new Vector&lt;B&gt;(); } public void setName(String[] name){ this.name = name; } public String[] getName(){ return name; } public void setClaB(Vector&lt;B&gt; claB){ this.claB = claB; } public Vector&lt;B&gt; getClaB(){ return claB; } protected A clone() throws CloneNotSupportedException { A a = (A)super.clone(); a.name = (String[])name.clone(); a.claB = new Vector&lt;B&gt;(); for(int i = 0;i &lt; claB.size();i++){ a.claB.add((B)claB.get(i).clone());//当然Class&nbsp;B也要实现相应clone方法&nbsp;&nbsp; } return a; }}","link":"/2019/11/07/java/listDeepCopy/"},{"title":"Hexo使用总结","text":"1.创建新页面1hexo new page --path a\\b 2.不同的主题设置不同的Website可以在用不同的yml，编译的时候，用不同theme的yml代替_config.yml编译 1hexo s --config xxx.yml","link":"/2019/09/07/hexo/common/"}],"tags":[{"name":"第三方App","slug":"第三方App","link":"/tags/%E7%AC%AC%E4%B8%89%E6%96%B9App/"},{"name":"手机弹窗","slug":"手机弹窗","link":"/tags/%E6%89%8B%E6%9C%BA%E5%BC%B9%E7%AA%97/"},{"name":"验证码输入框","slug":"验证码输入框","link":"/tags/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%BE%93%E5%85%A5%E6%A1%86/"},{"name":"集合","slug":"集合","link":"/tags/%E9%9B%86%E5%90%88/"},{"name":"总结","slug":"总结","link":"/tags/%E6%80%BB%E7%BB%93/"}],"categories":[{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"java","slug":"java","link":"/categories/java/"}]}